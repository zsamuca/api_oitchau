DocumentaÃ§Ã£o â€” IntegraÃ§Ã£o Power BI com API Oitchau (Banco de Horas)
ğŸ¯ Objetivo do Projeto

Construir uma base automÃ¡tica de histÃ³rico de saldo de banco de horas dos colaboradores ativos diretamente do sistema de ponto (Oitchau), sem exportaÃ§Ã£o manual.

A API nÃ£o fornece um relatÃ³rio pronto.
Ela fornece dados atÃ´micos (por colaborador e por data).

Logo, o Power BI passa a atuar como um consumidor da API e tambÃ©m como um reconstrutor do histÃ³rico.

ğŸ§  Como funciona uma API (explicaÃ§Ã£o essencial)

Uma API REST funciona como um garÃ§om:

VocÃª pede	API faz
â€œsaldo do JoÃ£oâ€	busca no banco
â€œsaldo em 31/12â€	consulta snapshot
â€œlista funcionÃ¡riosâ€	retorna cadastro

VocÃª nÃ£o acessa o banco de dados diretamente.
VocÃª faz requisiÃ§Ãµes HTTP.

O Power BI estÃ¡ fazendo chamadas do tipo:

https://api.oitchau.com.br/endpoint?parametros


Cada chamada retorna um JSON.

ğŸªª Etapa 1 â€” AutenticaÃ§Ã£o (Token)
Por quÃª?

A API precisa saber quem vocÃª Ã©.
VocÃª nÃ£o usa login/senha â†’ vocÃª usa Bearer Token.

Isso segue o padrÃ£o OAuth2 Client Credentials.

O fluxo real Ã©:

Client ID + Client Secret â†’ Oitchau â†’ Token â†’ PermissÃ£o temporÃ¡ria


Esse token Ã© como um crachÃ¡ temporÃ¡rio.

Consulta criada: Token_Oitchau

(essa vocÃª jÃ¡ tinha, entÃ£o sÃ³ documente:)

FunÃ§Ã£o:
Obter token de acesso para todas as chamadas seguintes.

Por que Ã© necessÃ¡rio?
Toda requisiÃ§Ã£o da API exige o header:

Authorization: Bearer TOKEN


Sem isso â†’ erro 401 (nÃ£o autorizado).

ğŸ‘¥ Etapa 2 â€” Listar colaboradores
Problema

O endpoint de banco de horas nÃ£o aceita matrÃ­cula.

Ele exige:

employeeUuid


A matrÃ­cula Ã© um dado humano.
O UUID Ã© a chave primÃ¡ria do banco de dados do sistema.

Ou seja:

Campo	Uso
matrÃ­cula	RH usa
uuid	sistema usa
Endpoint utilizado
GET /v2/public/integrations_api/employees

Consulta criada: Lista_Funcionarios
let
    Host = "https://api.oitchau.com.br",
    Token = Token_Oitchau,

    Response =
        Json.Document(
            Web.Contents(
                Host,
                [
                    RelativePath = "v2/public/integrations_api/employees",
                    Headers = [
                        Authorization = "Bearer " & Token,
                        Accept = "application/json"
                    ]
                ]
            )
        ),

    content = Response[content],
    tabela = Table.FromList(content, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
    expandido = Table.ExpandRecordColumn(tabela, "Column1", {"uuid","matricula","fullName","active"}, {"uuid","matricula","nome","ativo"})
in
    expandido

Por que fizemos isso?

Porque precisamos do uuid de cada colaborador para consultar o banco de horas.

ğŸ“… Etapa 3 â€” Definir datas de consulta
Problema encontrado

Consultar todos os dias causaria:

350 funcionÃ¡rios Ã— 400 dias = 140.000 requisiÃ§Ãµes


Isso:

demora horas

pode bloquear a API

pode expirar token

SoluÃ§Ã£o adotada

Consultar apenas datas de fechamento bimestral + saldo atual (D-1).

Consulta criada: Datas_Consulta_BH
let
    Hoje = Date.From(DateTime.LocalNow()),
    Ontem = Date.AddDays(Hoje, -1),

    DatasFixas2025 = {
        #date(2025, 2, 28),
        #date(2025, 4, 30),
        #date(2025, 6, 30),
        #date(2025, 8, 31),
        #date(2025,10,31),
        #date(2025,12,31)
    },

    Datas = List.Distinct(List.Combine({DatasFixas2025, {Ontem}})),
    Tabela = Table.FromList(Datas, Splitter.SplitByNothing(), {"Data"}),
    Tipo = Table.TransformColumnTypes(Tabela, {{"Data", type date}}),
    Ordenado = Table.Sort(Tipo, {{"Data", Order.Ascending}})
in
    Ordenado

Por que?

A API retorna o saldo na data consultada, nÃ£o um histÃ³rico pronto.

Logo:

NÃ³s reconstruÃ­mos o histÃ³rico escolhendo pontos de referÃªncia.

ğŸ§¾ Etapa 4 â€” Buscar data de admissÃ£o
Problema

Admitidos em 2026 apareciam em 2025 com saldo 0.

Isso nÃ£o Ã© correto.
O correto Ã© null (a pessoa ainda nÃ£o existia na empresa).

Endpoint utilizado
GET /employees/find?matricula=XXXX

FunÃ§Ã£o criada: fnStartDatePorMatricula
(Matricula as text) as nullable date =>
let
    Host = "https://api.oitchau.com.br",
    Token = Token_Oitchau,

    Response =
        Json.Document(
            Web.Contents(
                Host,
                [
                    RelativePath = "v2/public/integrations_api/employees/find",
                    Query = [ matricula = Matricula ],
                    Headers = [
                        Authorization = "Bearer " & Token,
                        Accept = "application/json"
                    ]
                ]
            )
        ),

    Conteudo = try Response[content] otherwise null,
    StartText = try Text.From(Conteudo[startDate]) otherwise null,
    StartDate = try Date.From(StartText) otherwise null
in
    StartDate

ğŸ§® Etapa 5 â€” Buscar saldo de banco de horas
Endpoint principal
/employees/hoursbank/totals


Este endpoint retorna:

o saldo acumulado do banco de horas naquela data especÃ­fica.

Problema importante descoberto

O retorno da API nÃ£o tem estrutura fixa.

O campo totals pode ser:

nÃºmero

record

lista

Ou seja, nÃ£o dava pra assumir:

positive / negative


Precisamos ler dinamicamente.

FunÃ§Ã£o criada: fnBHHistorico
(EmployeeUuid as text, DataConsulta as date) =>
let
    Host = "https://api.oitchau.com.br",
    Token = Token_Oitchau,

    Response =
        Json.Document(
            Web.Contents(
                Host,
                [
                    RelativePath = "v2/public/integrations_api/employees/hoursbank/totals",
                    Query = [
                        employeeUuid = EmployeeUuid,
                        date = Date.ToText(DataConsulta, "yyyy-MM-dd")
                    ],
                    Headers = [
                        Authorization = "Bearer " & Token,
                        Accept = "application/json"
                    ]
                ]
            )
        ),

    TotalsAny = try Response[totals] otherwise null,

    Carteiras =
        if TotalsAny = null then
            {}
        else if Value.Is(TotalsAny, type record) then
            Record.FieldValues(TotalsAny)
        else if Value.Is(TotalsAny, type list) then
            TotalsAny
        else
            { TotalsAny },

    ToNumber = (x as any) as number =>
        let n = try Number.From(x) otherwise null
        in if n = null then 0 else n,

    SomaCarteira = (c as any) as number =>
        if c = null then
            0
        else if Value.Is(c, type record) then
            List.Sum(List.Transform(Record.FieldValues(c), each ToNumber(_)))
        else
            ToNumber(c),

    SaldoMinutos = List.Sum(List.Transform(Carteiras, each SomaCarteira(_)))
in
    SaldoMinutos

Por que isso foi necessÃ¡rio?

Porque a API nÃ£o retorna â€œo saldo prontoâ€.
Ela retorna carteiras internas do motor de jornada.

Essa funÃ§Ã£o reconstrÃ³i o saldo verdadeiro.

ğŸš¦ Etapa 6 â€” Respeitar data de admissÃ£o

Regra aplicada:

if [Data] < [startDate] then null
else fnBHHistorico([uuid], Date.From([Data]))

Motivo

Garantir consistÃªncia histÃ³rica:

antes da admissÃ£o â†’ null

apÃ³s admissÃ£o â†’ saldo vÃ¡lido

ğŸ“Š Etapa 7 â€” Colunas finais

Saldo em horas:

if [SaldoMinutos] = null then null else [SaldoMinutos] / 60

ğŸ§  Resultado final (o que vocÃª construiu)

VocÃª criou:

Um Data Mart de Banco de Horas baseado em API REST.

O Power BI agora:

autentica

consulta cadastro

consulta data de admissÃ£o

consulta saldo histÃ³rico

reconstrÃ³i histÃ³rico corporativo

Isso nÃ£o Ã© apenas relatÃ³rio.
Isso Ã© integraÃ§Ã£o de sistemas.

O que essa base permite analisar

evoluÃ§Ã£o do banco por colaborador

passivo trabalhista

Ã¡reas que mais acumulam horas

colaboradores sempre negativos

necessidade de compensaÃ§Ã£o

comportamento por gestor
